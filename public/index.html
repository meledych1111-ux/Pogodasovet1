<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>–¢–µ—Ç—Ä–∏—Å | –ü–æ–≥–æ–¥–Ω—ã–π –±–æ—Ç</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: linear-gradient(135deg, #8A2BE2 0%, #DA70D6 100%);
            font-family: 'Arial', sans-serif;
            color: white;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .container {
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        header {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 5px;
        }
        
        h1 {
            font-size: 22px;
            margin-bottom: 5px;
            color: #FFD700;
        }
        
        .subtitle {
            font-size: 12px;
            opacity: 0.9;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-box {
            flex: 1;
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 5px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            display: block;
            color: #FFD700;
        }
        
        .stat-label {
            font-size: 11px;
            opacity: 0.8;
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 10px;
        }
        
        .game-board-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1/1;
            max-height: 60vh;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 8px;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            border-radius: 10px;
            background: #111;
            touch-action: none;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .dpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            height: 180px;
        }
        
        .dpad-btn {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            color: white;
            border-radius: 15px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            -webkit-tap-highlight-color: transparent;
        }
        
        .dpad-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }
        
        #rotate {
            grid-column: 2;
            grid-row: 1;
            background: rgba(255, 215, 0, 0.2);
            border-color: rgba(255, 215, 0, 0.3);
        }
        
        #left {
            grid-column: 1;
            grid-row: 2;
        }
        
        #right {
            grid-column: 3;
            grid-row: 2;
        }
        
        #down {
            grid-column: 2;
            grid-row: 2;
        }
        
        #drop {
            grid-column: 2;
            grid-row: 3;
            background: rgba(255, 69, 0, 0.2);
            border-color: rgba(255, 69, 0, 0.3);
            font-size: 20px;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .action-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 14px;
            border-radius: 15px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.1s;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .action-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.98);
        }
        
        #start {
            background: rgba(50, 205, 50, 0.3);
            border-color: rgba(50, 205, 50, 0.4);
        }
        
        #pause {
            background: rgba(255, 165, 0, 0.3);
            border-color: rgba(255, 165, 0, 0.4);
        }
        
        .touch-info {
            text-align: center;
            font-size: 11px;
            opacity: 0.7;
            padding: 5px;
            margin-top: 5px;
        }
        
        footer {
            text-align: center;
            font-size: 10px;
            opacity: 0.6;
            padding: 10px;
            margin-top: auto;
        }
        
        /* –ê–¥–∞–ø—Ç–∏–≤ –¥–ª—è –º–∞–ª–µ–Ω—å–∫–∏—Ö —ç–∫—Ä–∞–Ω–æ–≤ */
        @media (max-height: 700px) {
            .dpad {
                height: 150px;
            }
            
            .stat-box {
                padding: 8px 4px;
            }
            
            .stat-value {
                font-size: 20px;
            }
        }
        
        /* –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ zoom –Ω–∞ iOS */
        @supports (-webkit-touch-callout: none) {
            input, textarea {
                font-size: 16px !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéÆ –¢–µ—Ç—Ä–∏—Å </h1>
            <p class="subtitle">–ú–æ—è –∏–≥—Ä–∞</p>
            
            <div class="stats">
                <div class="stat-box">
                    <span class="stat-value" id="score">0</span>
                    <span class="stat-label">–û—á–∫–∏</span>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="level">1</span>
                    <span class="stat-label">–£—Ä–æ–≤–µ–Ω—å</span>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="lines">0</span>
                    <span class="stat-label">–õ–∏–Ω–∏–∏</span>
                </div>
            </div>
        </header>

        <div class="game-area">
            <div class="game-board-container">
                <canvas id="tetris"></canvas>
            </div>
            
            <div class="controls">
                <div class="dpad">
                    <button class="dpad-btn" id="left">‚Üê</button>
                    <button class="dpad-btn" id="rotate">‚Üª</button>
                    <button class="dpad-btn" id="right">‚Üí</button>
                    <button class="dpad-btn" id="down">‚Üì</button>
                    <button class="dpad-btn" id="drop">üí•</button>
                </div>
                
                <div class="action-buttons">
                    <button class="action-btn" id="start">
                        <span>‚ñ∂Ô∏è</span>
                        <span>–°–¢–ê–†–¢</span>
                    </button>
                    <button class="action-btn" id="pause">
                        <span>‚è∏Ô∏è</span>
                        <span>–ü–ê–£–ó–ê</span>
                    </button>
                </div>
                
                <div class="touch-info">
                    üí° –ú–æ–∂–Ω–æ —Ç–∞–∫–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–≤–∞–π–ø—ã –∏ –∫–Ω–æ–ø–∫–∏ –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ
                </div>
            </div>
        </div>

        <footer>
            <p>üéÆ –¢–µ—Ç—Ä–∏—Å –≤ Telegram ‚Ä¢ –ò–≥—Ä–∞–π—Ç–µ –≥–¥–µ —É–≥–æ–¥–Ω–æ!</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // =================== –ö–û–ù–°–¢–ê–ù–¢–´ ===================
            const canvas = document.getElementById('tetris');
            const context = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const levelElement = document.getElementById('level');
            const linesElement = document.getElementById('lines');
            const startButton = document.getElementById('start');
            const pauseButton = document.getElementById('pause');
            
            // –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
            const COLS = 12; // –£–≤–µ–ª–∏—á–∏–ª–∏ —à–∏—Ä–∏–Ω—É –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –ø–æ–ª—è
            const ROWS = 22; // –£–≤–µ–ª–∏—á–∏–ª–∏ –≤—ã—Å–æ—Ç—É
            const BLOCK_SIZE = Math.min(
                Math.floor(window.innerWidth * 0.8 / COLS),
                Math.floor(window.innerHeight * 0.5 / ROWS)
            );
            
            // –¶–≤–µ—Ç–∞ –≤ —Å—Ç–∏–ª–µ K-Drama (–ø–∞—Å—Ç–µ–ª—å–Ω—ã–µ, –∫—Ä–∞—Å–∏–≤—ã–µ)
            const COLORS = [
                null,
                '#FFB6C1', // I - —Å–≤–µ—Ç–ª–æ-—Ä–æ–∑–æ–≤—ã–π (–∫–∞–∫ —Å–∞–∫—É—Ä–∞)
                '#87CEEB', // J - –Ω–µ–±–µ—Å–Ω–æ-–≥–æ–ª—É–±–æ–π
                '#98FB98', // L - –º—è—Ç–Ω–æ-–∑–µ–ª–µ–Ω—ã–π
                '#FFD700', // O - –∑–æ–ª–æ—Ç–æ–π
                '#DA70D6', // S - –æ—Ä—Ö–∏–¥–µ—è
                '#FFA07A', // T - —Å–≤–µ—Ç–ª–æ-–ª–æ—Å–æ—Å–µ–≤—ã–π
                '#BA55D3'  // Z - —Å—Ä–µ–¥–Ω—è—è –æ—Ä—Ö–∏–¥–µ—è
            ];
            
            // –¢–µ–Ω–∏ –¥–ª—è –æ–±—ä–µ–º–Ω–æ—Å—Ç–∏
            const SHADOW_COLORS = [
                null,
                '#FF69B4', // I
                '#1E90FF', // J
                '#32CD32', // L
                '#FF8C00', // O
                '#9932CC', // S
                '#FF4500', // T
                '#8A2BE2'  // Z
            ];
            
            // –§–∏–≥—É—Ä—ã (–Ω–µ–º–Ω–æ–≥–æ —É–º–µ–Ω—å—à–µ–Ω—ã –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –ø–æ–ª—è)
            const SHAPES = [
                null,
                [ // I
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,1,1,1,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0]
                ],
                [ // J
                    [0,0,0,0],
                    [2,0,0,0],
                    [2,2,2,0],
                    [0,0,0,0]
                ],
                [ // L
                    [0,0,0,0],
                    [0,0,3,0],
                    [3,3,3,0],
                    [0,0,0,0]
                ],
                [ // O
                    [0,0,0,0],
                    [0,4,4,0],
                    [0,4,4,0],
                    [0,0,0,0]
                ],
                [ // S
                    [0,0,0,0],
                    [0,5,5,0],
                    [5,5,0,0],
                    [0,0,0,0]
                ],
                [ // T
                    [0,0,0,0],
                    [0,6,0,0],
                    [6,6,6,0],
                    [0,0,0,0]
                ],
                [ // Z
                    [0,0,0,0],
                    [7,7,0,0],
                    [0,7,7,0],
                    [0,0,0,0]
                ]
            ];
            
            // =================== –ò–ì–†–û–í–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===================
            let board = createMatrix(COLS, ROWS);
            let player = {
                pos: {x: 0, y: 0},
                matrix: null,
                score: 0,
                level: 1,
                lines: 0,
                dropInterval: 1200, // –ú–µ–¥–ª–µ–Ω–Ω–µ–µ –¥–ª—è –Ω–∞—á–∞–ª–∞
                dropCounter: 0,
                gameOver: false,
                paused: false,
                nextPiece: null,
                lastMoveTime: 0,
                moveDelay: 100 // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –¥–≤–∏–∂–µ–Ω–∏—è–º–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –¥–µ—Ä–≥–∞–Ω–∏–π
            };
            
            // =================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–ê–ù–í–ê–°–ê ===================
            function initCanvas() {
                const container = canvas.parentElement;
                const containerWidth = container.clientWidth - 16; // –£—á–∏—Ç—ã–≤–∞–µ–º padding
                const containerHeight = container.clientHeight - 16;
                
                const blockSize = Math.min(
                    Math.floor(containerWidth / COLS),
                    Math.floor(containerHeight / ROWS)
                );
                
                canvas.width = COLS * blockSize;
                canvas.height = ROWS * blockSize;
                
                // –û—Ç–∫–ª—é—á–∞–µ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ —Ç–∞—á-—É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö
                canvas.style.touchAction = 'none';
                canvas.style.webkitTouchCallout = 'none';
                canvas.style.webkitUserSelect = 'none';
                
                draw();
            }
            
            // =================== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò ===================
            function createMatrix(w, h) {
                const matrix = [];
                for (let i = 0; i < h; i++) {
                    matrix.push(new Array(w).fill(0));
                }
                return matrix;
            }
            
            function createPiece(type) {
                return JSON.parse(JSON.stringify(SHAPES[type]));
            }
            
            // –£–ª—É—á—à–µ–Ω–Ω–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ –±–ª–æ–∫–æ–≤ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞–º–∏
            function drawBlock(x, y, colorIndex) {
                const color = COLORS[colorIndex];
                const shadowColor = SHADOW_COLORS[colorIndex];
                const size = BLOCK_SIZE;
                
                // –û—Å–Ω–æ–≤–Ω–æ–π –±–ª–æ–∫ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
                const gradient = context.createLinearGradient(
                    x * size, y * size,
                    x * size + size, y * size + size
                );
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, shadowColor);
                
                context.fillStyle = gradient;
                context.fillRect(x * size, y * size, size, size);
                
                // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ç–µ–Ω—å –¥–ª—è –æ–±—ä–µ–º–∞
                context.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                context.lineWidth = 1;
                context.strokeRect(x * size + 1, y * size + 1, size - 2, size - 2);
                
                // –ë–ª–∏–∫ —Å–≤–µ—Ä—Ö—É
                context.fillStyle = 'rgba(255, 255, 255, 0.2)';
                context.fillRect(x * size, y * size, size, 2);
                context.fillRect(x * size, y * size, 2, size);
                
                // –¢–µ–Ω—å —Å–Ω–∏–∑—É
                context.fillStyle = 'rgba(0, 0, 0, 0.2)';
                context.fillRect(x * size + 2, y * size + size - 2, size - 2, 2);
                context.fillRect(x * size + size - 2, y * size + 2, 2, size - 2);
            }
            
            function drawMatrix(matrix, offset) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            drawBlock(x + offset.x, y + offset.y, value);
                        }
                    });
                });
            }
            
            function drawBoard() {
                // –ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ñ–æ–Ω –ø–æ–ª—è
                const bgGradient = context.createLinearGradient(0, 0, 0, canvas.height);
                bgGradient.addColorStop(0, '#1a1a2e');
                bgGradient.addColorStop(1, '#16213e');
                context.fillStyle = bgGradient;
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // –°–µ—Ç–∫–∞ –ø–æ–ª—è (–±–æ–ª–µ–µ —Ç–æ–Ω–∫–∞—è)
                context.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                context.lineWidth = 0.5;
                
                // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
                for (let x = 0; x <= COLS; x++) {
                    context.beginPath();
                    context.moveTo(x * BLOCK_SIZE, 0);
                    context.lineTo(x * BLOCK_SIZE, canvas.height);
                    context.stroke();
                }
                
                // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
                for (let y = 0; y <= ROWS; y++) {
                    context.beginPath();
                    context.moveTo(0, y * BLOCK_SIZE);
                    context.lineTo(canvas.width, y * BLOCK_SIZE);
                    context.stroke();
                }
                
                // –û–±–≤–æ–¥–∫–∞ –ø–æ–ª—è
                context.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                context.lineWidth = 2;
                context.strokeRect(0, 0, canvas.width, canvas.height);
            }
            
            function drawNextPiece() {
                if (!player.nextPiece) return;
                
                const size = BLOCK_SIZE * 0.7; // –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è –ø–∞–Ω–µ–ª–∏ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
                const offsetX = COLS + 1;
                const offsetY = 1;
                
                // –§–æ–Ω –ø–∞–Ω–µ–ª–∏ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
                context.fillStyle = 'rgba(255, 255, 255, 0.1)';
                context.fillRect(offsetX * BLOCK_SIZE, offsetY * BLOCK_SIZE, 5 * size, 5 * size);
                context.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                context.lineWidth = 1;
                context.strokeRect(offsetX * BLOCK_SIZE, offsetY * BLOCK_SIZE, 5 * size, 5 * size);
                
                // –¢–µ–∫—Å—Ç
                context.fillStyle = 'white';
                context.font = 'bold 12px Arial';
                context.textAlign = 'center';
                context.fillText('–°–ª–µ–¥—É—é—â–∞—è:', offsetX * BLOCK_SIZE + 2.5 * size, offsetY * BLOCK_SIZE - 5);
                
                // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —É–º–µ–Ω—å—à–µ–Ω–Ω–æ–π —Ñ–∏–≥—É—Ä—ã
                player.nextPiece.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            const color = COLORS[value];
                            context.fillStyle = color;
                            context.fillRect(
                                offsetX * BLOCK_SIZE + x * size,
                                offsetY * BLOCK_SIZE + y * size,
                                size - 1,
                                size - 1
                            );
                        }
                    });
                });
            }
            
            function draw() {
                // –û—á–∏—Å—Ç–∫–∞
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                // –†–∏—Å—É–µ–º –ø–æ–ª–µ
                drawBoard();
                
                // –†–∏—Å—É–µ–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –±–ª–æ–∫–∏
                drawMatrix(board, {x: 0, y: 0});
                
                // –†–∏—Å—É–µ–º —Ç–µ–∫—É—â—É—é —Ñ–∏–≥—É—Ä—É
                if (player.matrix) {
                    drawMatrix(player.matrix, player.pos);
                }
                
                // –†–∏—Å—É–µ–º —Å–ª–µ–¥—É—é—â—É—é —Ñ–∏–≥—É—Ä—É
                drawNextPiece();
                
                // –°–æ–æ–±—â–µ–Ω–∏—è –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –∏–≥—Ä—ã
                if (player.paused && !player.gameOver) {
                    context.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    
                    context.fillStyle = '#FFD700';
                    context.font = 'bold 28px Arial';
                    context.textAlign = 'center';
                    context.fillText('–ü–ê–£–ó–ê', canvas.width / 2, canvas.height / 2 - 20);
                    context.font = '16px Arial';
                    context.fillStyle = 'white';
                    context.fillText('–ù–∞–∂–º–∏—Ç–µ –ü–ê–£–ó–ê –∏–ª–∏ P', canvas.width / 2, canvas.height / 2 + 20);
                }
                
                if (player.gameOver) {
                    context.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    
                    context.fillStyle = '#FF6B6B';
                    context.font = 'bold 32px Arial';
                    context.textAlign = 'center';
                    context.fillText('–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê', canvas.width / 2, canvas.height / 2 - 50);
                    
                    context.fillStyle = '#FFD700';
                    context.font = '24px Arial';
                    context.fillText(`–°—á—ë—Ç: ${player.score}`, canvas.width / 2, canvas.height / 2);
                    
                    context.fillStyle = 'white';
                    context.font = '18px Arial';
                    context.fillText('–ù–∞–∂–º–∏—Ç–µ –°–¢–ê–†–¢', canvas.width / 2, canvas.height / 2 + 50);
                }
            }
            
            // =================== –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ===================
            function merge() {
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            const boardY = y + player.pos.y;
                            const boardX = x + player.pos.x;
                            if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
                                board[boardY][boardX] = value;
                            }
                        }
                    });
                });
            }
            
            function collide() {
                const [m, o] = [player.matrix, player.pos];
                
                for (let y = 0; y < m.length; y++) {
                    for (let x = 0; x < m[y].length; x++) {
                        if (m[y][x] !== 0) {
                            const boardY = y + o.y;
                            const boardX = x + o.x;
                            
                            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü
                            if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                                return true;
                            }
                            
                            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—Ä—É–≥–∏—Ö –±–ª–æ–∫–æ–≤
                            if (boardY >= 0 && board[boardY][boardX] !== 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            // –£–ª—É—á—à–µ–Ω–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π –¥–ª—è —Ç–∞—á-—É—Å—Ç—Ä–æ–π—Å—Ç–≤
            function playerMove(dir) {
                if (player.paused || player.gameOver || !player.matrix) return;
                
                const now = Date.now();
                if (now - player.lastMoveTime < player.moveDelay) return;
                player.lastMoveTime = now;
                
                player.pos.x += dir;
                if (collide()) {
                    player.pos.x -= dir;
                }
                draw();
            }
            
            function playerRotate() {
                if (player.paused || player.gameOver || !player.matrix) return;
                
                const now = Date.now();
                if (now - player.lastMoveTime < player.moveDelay) return;
                player.lastMoveTime = now;
                
                const pos = player.pos.x;
                const originalMatrix = JSON.parse(JSON.stringify(player.matrix));
                let offset = 1;
                
                rotate(player.matrix);
                
                while (collide()) {
                    player.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (Math.abs(offset) > player.matrix[0].length) {
                        player.pos.x = pos;
                        player.matrix = originalMatrix;
                        return;
                    }
                }
                draw();
            }
            
            function rotate(matrix) {
                const N = matrix.length;
                const M = matrix[0].length;
                const rotated = [];
                
                for (let i = 0; i < M; i++) {
                    rotated[i] = [];
                    for (let j = 0; j < N; j++) {
                        rotated[i][j] = matrix[N - 1 - j][i];
                    }
                }
                
                matrix.length = 0;
                for (let i = 0; i < rotated.length; i++) {
                    matrix[i] = rotated[i];
                }
            }
            
            function playerDrop() {
                if (player.paused || player.gameOver || !player.matrix) return;
                
                player.pos.y++;
                if (collide()) {
                    player.pos.y--;
                    merge();
                    playerReset();
                    sweep();
                }
                player.dropCounter = 0;
                draw();
            }
            
            function playerDropInstant() {
                if (player.paused || player.gameOver || !player.matrix) return;
                
                while (!collide()) {
                    player.pos.y++;
                }
                player.pos.y--;
                merge();
                playerReset();
                sweep();
                draw();
            }
            
            function playerReset() {
                // –ï—Å–ª–∏ –Ω–µ—Ç —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∏–≥—É—Ä—ã, —Å–æ–∑–¥–∞–µ–º
                if (!player.nextPiece) {
                    const pieces = [1,2,3,4,5,6,7];
                    const type = pieces[Math.floor(Math.random() * pieces.length)];
                    player.nextPiece = createPiece(type);
                }
                
                // –¢–µ–∫—É—â–∞—è —Ñ–∏–≥—É—Ä–∞ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å–ª–µ–¥—É—é—â–µ–π
                player.matrix = player.nextPiece;
                player.pos.y = 0;
                player.pos.x = Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);
                
                // –ù–æ–≤–∞—è —Å–ª–µ–¥—É—é—â–∞—è —Ñ–∏–≥—É—Ä–∞
                const pieces = [1,2,3,4,5,6,7];
                const type = pieces[Math.floor(Math.random() * pieces.length)];
                player.nextPiece = createPiece(type);
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã
                if (collide()) {
                    player.gameOver = true;
                    sendScoreToBot();
                }
            }
            
            function sweep() {
                let rowsCleared = 0;
                
                outer: for (let y = ROWS - 1; y >= 0; y--) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x] === 0) {
                            continue outer;
                        }
                    }
                    
                    // –£–¥–∞–ª—è–µ–º –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É
                    const row = board.splice(y, 1)[0];
                    row.fill(0);
                    board.unshift(row);
                    rowsCleared++;
                    y++; // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç—É –∂–µ –ø–æ–∑–∏—Ü–∏—é —Å–Ω–æ–≤–∞
                }
                
                if (rowsCleared > 0) {
                    // –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è —Å–∏—Å—Ç–µ–º–∞ –æ—á–∫–æ–≤ Tetris
                    const points = [40, 100, 300, 1200];
                    player.score += points[Math.min(rowsCleared - 1, 3)] * player.level;
                    player.lines += rowsCleared;
                    
                    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è
                    const newLevel = Math.floor(player.lines / 10) + 1;
                    if (newLevel > player.level) {
                        player.level = newLevel;
                        // –ü–ª–∞–≤–Ω–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ (–Ω–µ —Å–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ)
                        player.dropInterval = Math.max(150, 1200 - (player.level - 1) * 70);
                    }
                    
                    updateScore();
                    sendScoreToBot();
                }
            }
            
            function updateScore() {
                scoreElement.textContent = player.score;
                levelElement.textContent = player.level;
                linesElement.textContent = player.lines;
            }
            
            function sendScoreToBot() {
                if (window.Telegram && Telegram.WebApp) {
                    const data = {
                        action: 'tetris_score',
                        score: player.score,
                        level: player.level,
                        lines: player.lines,
                        gameOver: player.gameOver
                    };
                    Telegram.WebApp.sendData(JSON.stringify(data));
                }
            }
            
            function startGame() {
                if (player.gameOver) {
                    // –ü–æ–ª–Ω—ã–π —Å–±—Ä–æ—Å
                    board = createMatrix(COLS, ROWS);
                    player.score = 0;
                    player.level = 1;
                    player.lines = 0;
                    player.dropInterval = 1200;
                    player.gameOver = false;
                    player.paused = false;
                    player.nextPiece = null;
                    updateScore();
                }
                
                if (!player.matrix) {
                    playerReset();
                }
                
                player.paused = false;
                startButton.innerHTML = '<span>‚ñ∂Ô∏è</span><span>–°–¢–ê–†–¢</span>';
                pauseButton.innerHTML = '<span>‚è∏Ô∏è</span><span>–ü–ê–£–ó–ê</span>';
                draw();
            }
            
            function togglePause() {
                if (player.gameOver || !player.matrix) return;
                
                player.paused = !player.paused;
                pauseButton.innerHTML = player.paused 
                    ? '<span>‚ñ∂Ô∏è</span><span>–ü–†–û–î–û–õ–ñ–ò–¢–¨</span>'
                    : '<span>‚è∏Ô∏è</span><span>–ü–ê–£–ó–ê</span>';
                draw();
            }
            
            // =================== –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ===================
            let lastTime = 0;
            
            function update(time = 0) {
                const deltaTime = time - lastTime;
                lastTime = time;
                
                if (!player.paused && !player.gameOver && player.matrix) {
                    player.dropCounter += deltaTime;
                    if (player.dropCounter > player.dropInterval) {
                        playerDrop();
                    }
                }
                
                draw();
                requestAnimationFrame(update);
            }
            
            // =================== –¢–ê–ß-–£–ü–†–ê–í–õ–ï–ù–ò–ï ===================
            let touchStartX = 0;
            let touchStartY = 0;
            let touchStartTime = 0;
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartTime = Date.now();
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (!e.changedTouches[0]) return;
                
                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;
                const deltaTime = Date.now() - touchStartTime;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è —Å–≤–∞–π–ø–∞
                if (distance < 20) return;
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–∞–π–ø–∞
                const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                const speed = distance / deltaTime;
                
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Å–≤–∞–π–ø
                    if (deltaX > 0) {
                        playerMove(1); // –í–ø—Ä–∞–≤–æ
                    } else {
                        playerMove(-1); // –í–ª–µ–≤–æ
                    }
                } else {
                    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Å–≤–∞–π–ø
                    if (deltaY > 0) {
                        if (speed > 0.5) {
                            playerDropInstant(); // –ë—ã—Å—Ç—Ä—ã–π —Å–≤–∞–π–ø –≤–Ω–∏–∑
                        } else {
                            playerDrop(); // –ú–µ–¥–ª–µ–Ω–Ω—ã–π —Å–≤–∞–π–ø
                        }
                    } else {
                        playerRotate(); // –°–≤–∞–π–ø –≤–≤–µ—Ä—Ö - –ø–æ–≤–æ—Ä–æ—Ç
                    }
                }
            }, { passive: false });
            
            // =================== –ö–ù–û–ü–û–ß–ù–û–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï ===================
            document.getElementById('left').addEventListener('touchstart', (e) => {
                e.preventDefault();
                playerMove(-1);
            });
            
            document.getElementById('right').addEventListener('touchstart', (e) => {
                e.preventDefault();
                playerMove(1);
            });
            
            document.getElementById('rotate').addEventListener('touchstart', (e) => {
                e.preventDefault();
                playerRotate();
            });
            
            document.getElementById('down').addEventListener('touchstart', (e) => {
                e.preventDefault();
                playerDrop();
            });
            
            document.getElementById('drop').addEventListener('touchstart', (e) => {
                e.preventDefault();
                playerDropInstant();
            });
            
            startButton.addEventListener('click', startGame);
            pauseButton.addEventListener('click', togglePause);
            
            // =================== –ö–õ–ê–í–ò–ê–¢–£–†–ê ===================
            document.addEventListener('keydown', (e) => {
                if (player.gameOver && e.key !== ' ') return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        e.preventDefault();
                        playerMove(-1);
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        e.preventDefault();
                        playerMove(1);
                        break;
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        e.preventDefault();
                        playerRotate();
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        e.preventDefault();
                        playerDrop();
                        break;
                    case ' ':
                        e.preventDefault();
                        playerDropInstant();
                        break;
                    case 'p':
                    case 'P':
                    case '–∑':
                    case '–ó':
                        e.preventDefault();
                        togglePause();
                        break;
                }
            });
            
            // =================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===================
            window.addEventListener('load', () => {
                // Telegram Web App
                if (window.Telegram && Telegram.WebApp) {
                    Telegram.WebApp.expand();
                    Telegram.WebApp.ready();
                    document.body.style.backgroundColor = Telegram.WebApp.backgroundColor;
                }
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–Ω–≤–∞—Å–∞
                initCanvas();
                
                // –ê–¥–∞–ø—Ç–∞—Ü–∏—è –∫ –∏–∑–º–µ–Ω–µ–Ω–∏—é —Ä–∞–∑–º–µ—Ä–∞ —ç–∫—Ä–∞–Ω–∞
                window.addEventListener('resize', initCanvas);
                
                // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
                update();
                draw();
            });
        });
        </script>
</body>
</html>
