<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>üéÆ –¢–µ—Ç—Ä–∏—Å | –ü–æ–≥–æ–¥–Ω—ã–π –±–æ—Ç</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: linear-gradient(135deg, #8A2BE2 0%, #DA70D6 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            color: white;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .container {
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        header {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 5px;
        }
        
        h1 {
            font-size: 22px;
            margin-bottom: 5px;
            color: #FFD700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 12px;
            opacity: 0.9;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-box {
            flex: 1;
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 5px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            display: block;
            color: #FFD700;
        }
        
        .stat-label {
            font-size: 11px;
            opacity: 0.8;
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 10px;
        }
        
        .game-board-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1/1;
            max-height: 60vh;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 8px;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            border-radius: 10px;
            background: #111;
            touch-action: none;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .dpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            height: 180px;
        }
        
        .dpad-btn {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            color: white;
            border-radius: 15px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            -webkit-tap-highlight-color: transparent;
        }
        
        .dpad-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }
        
        #rotate {
            grid-column: 2;
            grid-row: 1;
            background: rgba(255, 215, 0, 0.2);
            border-color: rgba(255, 215, 0, 0.3);
        }
        
        #left {
            grid-column: 1;
            grid-row: 2;
        }
        
        #right {
            grid-column: 3;
            grid-row: 2;
        }
        
        #down {
            grid-column: 2;
            grid-row: 2;
        }
        
        #drop {
            grid-column: 2;
            grid-row: 3;
            background: rgba(255, 69, 0, 0.2);
            border-color: rgba(255, 69, 0, 0.3);
            font-size: 20px;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .action-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 14px;
            border-radius: 15px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.1s;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .action-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.98);
        }
        
        #start {
            background: rgba(50, 205, 50, 0.3);
            border-color: rgba(50, 205, 50, 0.4);
        }
        
        #pause {
            background: rgba(255, 165, 0, 0.3);
            border-color: rgba(255, 165, 0, 0.4);
        }
        
        .touch-info {
            text-align: center;
            font-size: 11px;
            opacity: 0.7;
            padding: 5px;
            margin-top: 5px;
        }
        
        footer {
            text-align: center;
            font-size: 10px;
            opacity: 0.6;
            padding: 10px;
            margin-top: auto;
        }
        
        /* –ê–¥–∞–ø—Ç–∏–≤ –¥–ª—è –º–∞–ª–µ–Ω—å–∫–∏—Ö —ç–∫—Ä–∞–Ω–æ–≤ */
        @media (max-height: 700px) {
            .dpad {
                height: 150px;
            }
            
            .stat-box {
                padding: 8px 4px;
            }
            
            .stat-value {
                font-size: 20px;
            }
            
            h1 {
                font-size: 20px;
            }
        }
        
        @media (max-height: 600px) {
            .dpad {
                height: 130px;
            }
            
            header {
                padding: 10px;
            }
            
            .game-board-container {
                max-height: 55vh;
            }
        }
        
        /* –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ zoom –Ω–∞ iOS */
        @supports (-webkit-touch-callout: none) {
            input, textarea {
                font-size: 16px !important;
            }
        }
        
        /* –£–ª—É—á—à–µ–Ω–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —Ç–µ–º–Ω–æ–π/—Å–≤–µ—Ç–ª–æ–π —Ç–µ–º—ã Telegram */
        @media (prefers-color-scheme: dark) {
            body {
                background: linear-gradient(135deg, #4B0082 0%, #8A2BE2 100%);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéÆ –¢–µ—Ç—Ä–∏—Å</h1>
            <p class="subtitle">–ò–≥—Ä–∞ –≤ Telegram –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏</p>
            
            <div class="stats">
                <div class="stat-box">
                    <span class="stat-value" id="score">0</span>
                    <span class="stat-label">–û—á–∫–∏</span>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="level">1</span>
                    <span class="stat-label">–£—Ä–æ–≤–µ–Ω—å</span>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="lines">0</span>
                    <span class="stat-label">–õ–∏–Ω–∏–∏</span>
                </div>
            </div>
        </header>

        <div class="game-area">
            <div class="game-board-container">
                <canvas id="tetris"></canvas>
            </div>
            
            <div class="controls">
                <div class="dpad">
                    <button class="dpad-btn" id="left" aria-label="–í–ª–µ–≤–æ">‚Üê</button>
                    <button class="dpad-btn" id="rotate" aria-label="–ü–æ–≤–µ—Ä–Ω—É—Ç—å">‚Üª</button>
                    <button class="dpad-btn" id="right" aria-label="–í–ø—Ä–∞–≤–æ">‚Üí</button>
                    <button class="dpad-btn" id="down" aria-label="–í–Ω–∏–∑">‚Üì</button>
                    <button class="dpad-btn" id="drop" aria-label="–ú–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ –ø–∞–¥–µ–Ω–∏–µ">üí•</button>
                </div>
                
                <div class="action-buttons">
                    <button class="action-btn" id="start">
                        <span>‚ñ∂Ô∏è</span>
                        <span>–°–¢–ê–†–¢</span>
                    </button>
                    <button class="action-btn" id="pause">
                        <span>‚è∏Ô∏è</span>
                        <span>–ü–ê–£–ó–ê</span>
                    </button>
                </div>
                
                <div class="touch-info">
                    üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–≤–∞–π–ø—ã –Ω–∞ —ç–∫—Ä–∞–Ω–µ –∏–ª–∏ –∫–Ω–æ–ø–∫–∏ –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ
                </div>
            </div>
        </div>

        <footer>
            <p>üéÆ –¢–µ—Ç—Ä–∏—Å –≤ Telegram ‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ</p>
        </footer>
    </div>

    <script>
        (function() {
            'use strict';
            
            // =================== –ö–û–ù–°–¢–ê–ù–¢–´ ===================
            const canvas = document.getElementById('tetris');
            const context = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const levelElement = document.getElementById('level');
            const linesElement = document.getElementById('lines');
            const startButton = document.getElementById('start');
            const pauseButton = document.getElementById('pause');
            
            const COLS = 12;
            const ROWS = 22;
            let BLOCK_SIZE = 0; // –ë—É–¥–µ—Ç —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
            
            // –¶–≤–µ—Ç–∞ –≤ —Å—Ç–∏–ª–µ K-Drama (–ø–∞—Å—Ç–µ–ª—å–Ω—ã–µ, –∫—Ä–∞—Å–∏–≤—ã–µ)
            const COLORS = [
                null,
                '#FFB6C1', // I - —Å–≤–µ—Ç–ª–æ-—Ä–æ–∑–æ–≤—ã–π
                '#87CEEB', // J - –Ω–µ–±–µ—Å–Ω–æ-–≥–æ–ª—É–±–æ–π
                '#98FB98', // L - –º—è—Ç–Ω–æ-–∑–µ–ª–µ–Ω—ã–π
                '#FFD700', // O - –∑–æ–ª–æ—Ç–æ–π
                '#DA70D6', // S - –æ—Ä—Ö–∏–¥–µ—è
                '#FFA07A', // T - —Å–≤–µ—Ç–ª–æ-–ª–æ—Å–æ—Å–µ–≤—ã–π
                '#BA55D3'  // Z - —Å—Ä–µ–¥–Ω—è—è –æ—Ä—Ö–∏–¥–µ—è
            ];
            
            // –¢–µ–Ω–∏ –¥–ª—è –æ–±—ä–µ–º–Ω–æ—Å—Ç–∏
            const SHADOW_COLORS = [
                null,
                '#FF69B4', // I
                '#1E90FF', // J
                '#32CD32', // L
                '#FF8C00', // O
                '#9932CC', // S
                '#FF4500', // T
                '#8A2BE2'  // Z
            ];
            
            // –§–∏–≥—É—Ä—ã —Ç–µ—Ç—Ä–∏—Å–∞
            const SHAPES = [
                null,
                [ // I
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,1,1,1,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0]
                ],
                [ // J
                    [0,0,0,0],
                    [2,0,0,0],
                    [2,2,2,0],
                    [0,0,0,0]
                ],
                [ // L
                    [0,0,0,0],
                    [0,0,3,0],
                    [3,3,3,0],
                    [0,0,0,0]
                ],
                [ // O
                    [0,0,0,0],
                    [0,4,4,0],
                    [0,4,4,0],
                    [0,0,0,0]
                ],
                [ // S
                    [0,0,0,0],
                    [0,5,5,0],
                    [5,5,0,0],
                    [0,0,0,0]
                ],
                [ // T
                    [0,0,0,0],
                    [0,6,0,0],
                    [6,6,6,0],
                    [0,0,0,0]
                ],
                [ // Z
                    [0,0,0,0],
                    [7,7,0,0],
                    [0,7,7,0],
                    [0,0,0,0]
                ]
            ];
            
            // =================== –ò–ì–†–û–í–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===================
            let board = [];
            let player = {
                pos: {x: 0, y: 0},
                matrix: null,
                score: 0,
                level: 1,
                lines: 0,
                dropInterval: 1200,
                dropCounter: 0,
                gameOver: false,
                paused: false,
                nextPiece: null,
                lastMoveTime: 0,
                moveDelay: 100
            };
            
            // =================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===================
            function createMatrix(w, h) {
                const matrix = [];
                for (let i = 0; i < h; i++) {
                    matrix.push(new Array(w).fill(0));
                }
                return matrix;
            }
            
            function createPiece(type) {
                return JSON.parse(JSON.stringify(SHAPES[type]));
            }
            
            function calculateBlockSize() {
                const container = canvas.parentElement;
                const containerWidth = container.clientWidth - 16;
                const containerHeight = container.clientHeight - 16;
                
                return Math.min(
                    Math.floor(containerWidth / COLS),
                    Math.floor(containerHeight / ROWS)
                );
            }
            
            function initCanvas() {
                BLOCK_SIZE = calculateBlockSize();
                
                canvas.width = COLS * BLOCK_SIZE;
                canvas.height = ROWS * BLOCK_SIZE;
                
                // –û—Ç–∫–ª—é—á–∞–µ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ —Ç–∞—á-—É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö
                canvas.style.touchAction = 'none';
                canvas.style.webkitTouchCallout = 'none';
                canvas.style.webkitUserSelect = 'none';
                
                // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –ø–æ–ª–µ
                draw();
            }
            
            // =================== –û–¢–†–ò–°–û–í–ö–ê ===================
            function drawBlock(x, y, colorIndex) {
                if (!colorIndex || colorIndex < 1 || colorIndex > 7) return;
                
                const color = COLORS[colorIndex];
                const shadowColor = SHADOW_COLORS[colorIndex];
                
                // –û—Å–Ω–æ–≤–Ω–æ–π –±–ª–æ–∫ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
                const gradient = context.createLinearGradient(
                    x * BLOCK_SIZE, y * BLOCK_SIZE,
                    x * BLOCK_SIZE + BLOCK_SIZE, y * BLOCK_SIZE + BLOCK_SIZE
                );
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, shadowColor);
                
                context.fillStyle = gradient;
                context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                
                // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ç–µ–Ω—å –¥–ª—è –æ–±—ä–µ–º–∞
                context.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                context.lineWidth = 1;
                context.strokeRect(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
                
                // –ë–ª–∏–∫ —Å–≤–µ—Ä—Ö—É
                context.fillStyle = 'rgba(255, 255, 255, 0.2)';
                context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, 2);
                context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, 2, BLOCK_SIZE);
                
                // –¢–µ–Ω—å —Å–Ω–∏–∑—É
                context.fillStyle = 'rgba(0, 0, 0, 0.2)';
                context.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + BLOCK_SIZE - 2, BLOCK_SIZE - 2, 2);
                context.fillRect(x * BLOCK_SIZE + BLOCK_SIZE - 2, y * BLOCK_SIZE + 2, 2, BLOCK_SIZE - 2);
            }
            
            function drawMatrix(matrix, offset) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            drawBlock(x + offset.x, y + offset.y, value);
                        }
                    });
                });
            }
            
            function drawBoard() {
                // –ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ñ–æ–Ω –ø–æ–ª—è
                const bgGradient = context.createLinearGradient(0, 0, 0, canvas.height);
                bgGradient.addColorStop(0, '#1a1a2e');
                bgGradient.addColorStop(1, '#16213e');
                context.fillStyle = bgGradient;
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // –°–µ—Ç–∫–∞ –ø–æ–ª—è (–±–æ–ª–µ–µ —Ç–æ–Ω–∫–∞—è)
                context.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                context.lineWidth = 0.5;
                
                // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
                for (let x = 0; x <= COLS; x++) {
                    context.beginPath();
                    context.moveTo(x * BLOCK_SIZE, 0);
                    context.lineTo(x * BLOCK_SIZE, canvas.height);
                    context.stroke();
                }
                
                // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
                for (let y = 0; y <= ROWS; y++) {
                    context.beginPath();
                    context.moveTo(0, y * BLOCK_SIZE);
                    context.lineTo(canvas.width, y * BLOCK_SIZE);
                    context.stroke();
                }
                
                // –û–±–≤–æ–¥–∫–∞ –ø–æ–ª—è
                context.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                context.lineWidth = 2;
                context.strokeRect(0, 0, canvas.width, canvas.height);
            }
            
            function draw() {
                // –û—á–∏—Å—Ç–∫–∞
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                // –†–∏—Å—É–µ–º –ø–æ–ª–µ
                drawBoard();
                
                // –†–∏—Å—É–µ–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –±–ª–æ–∫–∏
                drawMatrix(board, {x: 0, y: 0});
                
                // –†–∏—Å—É–µ–º —Ç–µ–∫—É—â—É—é —Ñ–∏–≥—É—Ä—É
                if (player.matrix) {
                    drawMatrix(player.matrix, player.pos);
                }
                
                // –°–æ–æ–±—â–µ–Ω–∏—è –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –∏–≥—Ä—ã
                if (player.paused && !player.gameOver) {
                    context.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    
                    context.fillStyle = '#FFD700';
                    context.font = `bold ${Math.min(BLOCK_SIZE * 2, 28)}px Arial`;
                    context.textAlign = 'center';
                    context.fillText('–ü–ê–£–ó–ê', canvas.width / 2, canvas.height / 2 - 20);
                    context.font = `${Math.min(BLOCK_SIZE, 16)}px Arial`;
                    context.fillStyle = 'white';
                    context.fillText('–ù–∞–∂–º–∏—Ç–µ –ü–ê–£–ó–ê –∏–ª–∏ P', canvas.width / 2, canvas.height / 2 + 20);
                }
                
                if (player.gameOver) {
                    context.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    
                    context.fillStyle = '#FF6B6B';
                    context.font = `bold ${Math.min(BLOCK_SIZE * 2.5, 32)}px Arial`;
                    context.textAlign = 'center';
                    context.fillText('–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê', canvas.width / 2, canvas.height / 2 - 50);
                    
                    context.fillStyle = '#FFD700';
                    context.font = `${Math.min(BLOCK_SIZE * 2, 24)}px Arial`;
                    context.fillText(`–°—á—ë—Ç: ${player.score}`, canvas.width / 2, canvas.height / 2);
                    
                    context.fillStyle = 'white';
                    context.font = `${Math.min(BLOCK_SIZE * 1.5, 18)}px Arial`;
                    context.fillText('–ù–∞–∂–º–∏—Ç–µ –°–¢–ê–†–¢', canvas.width / 2, canvas.height / 2 + 50);
                }
            }
            
            // =================== –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ===================
            function merge() {
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            const boardY = y + player.pos.y;
                            const boardX = x + player.pos.x;
                            if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
                                board[boardY][boardX] = value;
                            }
                        }
                    });
                });
            }
            
            function collide() {
                const [m, o] = [player.matrix, player.pos];
                
                for (let y = 0; y < m.length; y++) {
                    for (let x = 0; x < m[y].length; x++) {
                        if (m[y][x] !== 0) {
                            const boardY = y + o.y;
                            const boardX = x + o.x;
                            
                            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü
                            if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                                return true;
                            }
                            
                            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—Ä—É–≥–∏—Ö –±–ª–æ–∫–æ–≤
                            if (boardY >= 0 && board[boardY][boardX] !== 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            function playerMove(dir) {
                if (player.paused || player.gameOver || !player.matrix) return;
                
                const now = Date.now();
                if (now - player.lastMoveTime < player.moveDelay) return;
                player.lastMoveTime = now;
                
                player.pos.x += dir;
                if (collide()) {
                    player.pos.x -= dir;
                }
                draw();
            }
            
            function playerRotate() {
                if (player.paused || player.gameOver || !player.matrix) return;
                
                const now = Date.now();
                if (now - player.lastMoveTime < player.moveDelay) return;
                player.lastMoveTime = now;
                
                const pos = player.pos.x;
                const originalMatrix = JSON.parse(JSON.stringify(player.matrix));
                let offset = 1;
                
                rotate(player.matrix);
                
                while (collide()) {
                    player.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (Math.abs(offset) > player.matrix[0].length) {
                        player.pos.x = pos;
                        player.matrix = originalMatrix;
                        return;
                    }
                }
                draw();
            }
            
            function rotate(matrix) {
                const N = matrix.length;
                const M = matrix[0].length;
                const rotated = [];
                
                for (let i = 0; i < M; i++) {
                    rotated[i] = [];
                    for (let j = 0; j < N; j++) {
                        rotated[i][j] = matrix[N - 1 - j][i];
                    }
                }
                
                matrix.length = 0;
                for (let i = 0; i < rotated.length; i++) {
                    matrix[i] = rotated[i];
                }
            }
            
            function playerDrop() {
                if (player.paused || player.gameOver || !player.matrix) return;
                
                player.pos.y++;
                if (collide()) {
                    player.pos.y--;
                    merge();
                    playerReset();
                    sweep();
                }
                player.dropCounter = 0;
                draw();
            }
            
            function playerDropInstant() {
                if (player.paused || player.gameOver || !player.matrix) return;
                
                while (!collide()) {
                    player.pos.y++;
                }
                player.pos.y--;
                merge();
                playerReset();
                sweep();
                draw();
            }
            
            function playerReset() {
                // –ï—Å–ª–∏ –Ω–µ—Ç —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∏–≥—É—Ä—ã, —Å–æ–∑–¥–∞–µ–º
                if (!player.nextPiece) {
                    const pieces = [1,2,3,4,5,6,7];
                    const type = pieces[Math.floor(Math.random() * pieces.length)];
                    player.nextPiece = createPiece(type);
                }
                
                // –¢–µ–∫—É—â–∞—è —Ñ–∏–≥—É—Ä–∞ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å–ª–µ–¥—É—é—â–µ–π
                player.matrix = player.nextPiece;
                player.pos.y = 0;
                player.pos.x = Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);
                
                // –ù–æ–≤–∞—è —Å–ª–µ–¥—É—é—â–∞—è —Ñ–∏–≥—É—Ä–∞
                const pieces = [1,2,3,4,5,6,7];
                const type = pieces[Math.floor(Math.random() * pieces.length)];
                player.nextPiece = createPiece(type);
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã
                if (collide()) {
                    player.gameOver = true;
                    sendScoreToBot(true);
                }
            }
            
            function sweep() {
                let rowsCleared = 0;
                
                outer: for (let y = ROWS - 1; y >= 0; y--) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x] === 0) {
                            continue outer;
                        }
                    }
                    
                    // –£–¥–∞–ª—è–µ–º –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É
                    const row = board.splice(y, 1)[0];
                    row.fill(0);
                    board.unshift(row);
                    rowsCleared++;
                    y++; // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç—É –∂–µ –ø–æ–∑–∏—Ü–∏—é —Å–Ω–æ–≤–∞
                }
                
                if (rowsCleared > 0) {
                    // –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è —Å–∏—Å—Ç–µ–º–∞ –æ—á–∫–æ–≤ Tetris
                    const points = [40, 100, 300, 1200];
                    player.score += points[Math.min(rowsCleared - 1, 3)] * player.level;
                    player.lines += rowsCleared;
                    
                    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è
                    const newLevel = Math.floor(player.lines / 10) + 1;
                    if (newLevel > player.level) {
                        player.level = newLevel;
                        // –ü–ª–∞–≤–Ω–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ (–Ω–µ —Å–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ)
                        player.dropInterval = Math.max(150, 1200 - (player.level - 1) * 70);
                    }
                    
                    updateScore();
                    sendScoreToBot(false);
                }
            }
            
            function updateScore() {
                scoreElement.textContent = player.score;
                levelElement.textContent = player.level;
                linesElement.textContent = player.lines;
            }
            
            function sendScoreToBot(gameOver = false) {
                if (window.Telegram && Telegram.WebApp) {
                    try {
                        const data = {
                            action: 'tetris_score',
                            score: player.score,
                            level: player.level,
                            lines: player.lines,
                            gameOver: gameOver
                        };
                        Telegram.WebApp.sendData(JSON.stringify(data));
                        console.log('üìä –û—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –≤ –±–æ—Ç–∞:', data);
                    } catch (error) {
                        console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –≤ –±–æ—Ç–∞:', error);
                    }
                }
            }
            
            function startGame() {
                if (player.gameOver) {
                    // –ü–æ–ª–Ω—ã–π —Å–±—Ä–æ—Å
                    board = createMatrix(COLS, ROWS);
                    player.score = 0;
                    player.level = 1;
                    player.lines = 0;
                    player.dropInterval = 1200;
                    player.gameOver = false;
                    player.paused = false;
                    player.nextPiece = null;
                    updateScore();
                }
                
                if (!player.matrix) {
                    playerReset();
                }
                
                player.paused = false;
                startButton.innerHTML = '<span>‚ñ∂Ô∏è</span><span>–°–¢–ê–†–¢</span>';
                pauseButton.innerHTML = '<span>‚è∏Ô∏è</span><span>–ü–ê–£–ó–ê</span>';
                draw();
            }
            
            function togglePause() {
                if (player.gameOver || !player.matrix) return;
                
                player.paused = !player.paused;
                pauseButton.innerHTML = player.paused 
                    ? '<span>‚ñ∂Ô∏è</span><span>–ü–†–û–î–û–õ–ñ–ò–¢–¨</span>'
                    : '<span>‚è∏Ô∏è</span><span>–ü–ê–£–ó–ê</span>';
                draw();
            }
            
            // =================== –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ===================
            let lastTime = 0;
            
            function update(time = 0) {
                const deltaTime = time - lastTime;
                lastTime = time;
                
                if (!player.paused && !player.gameOver && player.matrix) {
                    player.dropCounter += deltaTime;
                    if (player.dropCounter > player.dropInterval) {
                        playerDrop();
                    }
                }
                
                draw();
                requestAnimationFrame(update);
            }
            
            // =================== –£–ü–†–ê–í–õ–ï–ù–ò–ï ===================
            function setupTouchControls() {
                let touchStartX = 0;
                let touchStartY = 0;
                let touchStartTime = 0;
                
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    touchStartTime = Date.now();
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                }, { passive: false });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (!e.changedTouches[0]) return;
                    
                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    const deltaTime = Date.now() - touchStartTime;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è —Å–≤–∞–π–ø–∞
                    if (distance < 20) return;
                    
                    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–∞–π–ø–∞
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Å–≤–∞–π–ø
                        if (deltaX > 0) {
                            playerMove(1); // –í–ø—Ä–∞–≤–æ
                        } else {
                            playerMove(-1); // –í–ª–µ–≤–æ
                        }
                    } else {
                        // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Å–≤–∞–π–ø
                        if (deltaY > 0) {
                            const speed = distance / deltaTime;
                            if (speed > 0.5) {
                                playerDropInstant(); // –ë—ã—Å—Ç—Ä—ã–π —Å–≤–∞–π–ø –≤–Ω–∏–∑
                            } else {
                                playerDrop(); // –ú–µ–¥–ª–µ–Ω–Ω—ã–π —Å–≤–∞–π–ø
                            }
                        } else {
                            playerRotate(); // –°–≤–∞–π–ø –≤–≤–µ—Ä—Ö - –ø–æ–≤–æ—Ä–æ—Ç
                        }
                    }
                }, { passive: false });
            }
            
            function setupButtonControls() {
                const buttons = {
                    'left': () => playerMove(-1),
                    'right': () => playerMove(1),
                    'rotate': () => playerRotate(),
                    'down': () => playerDrop(),
                    'drop': () => playerDropInstant(),
                    'start': () => startGame(),
                    'pause': () => togglePause()
                };
                
                Object.keys(buttons).forEach(id => {
                    const button = document.getElementById(id);
                    if (button) {
                        button.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            buttons[id]();
                        });
                        button.addEventListener('click', buttons[id]);
                    }
                });
            }
            
            function setupKeyboardControls() {
                document.addEventListener('keydown', (e) => {
                    if (player.gameOver && e.key !== ' ') return;
                    
                    switch(e.key.toLowerCase()) {
                        case 'arrowleft':
                        case 'a':
                        case '—Ñ':
                            e.preventDefault();
                            playerMove(-1);
                            break;
                        case 'arrowright':
                        case 'd':
                        case '–≤':
                            e.preventDefault();
                            playerMove(1);
                            break;
                        case 'arrowup':
                        case 'w':
                        case '—Ü':
                            e.preventDefault();
                            playerRotate();
                            break;
                        case 'arrowdown':
                        case 's':
                        case '—ã':
                            e.preventDefault();
                            playerDrop();
                            break;
                        case ' ':
                            e.preventDefault();
                            playerDropInstant();
                            break;
                        case 'p':
                        case '–∑':
                            e.preventDefault();
                            togglePause();
                            break;
                        case 'enter':
                            e.preventDefault();
                            if (player.gameOver) startGame();
                            break;
                    }
                });
            }
            
            // =================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===================
            function init() {
                // Telegram Web App
                if (window.Telegram && Telegram.WebApp) {
                    Telegram.WebApp.expand();
                    Telegram.WebApp.ready();
                    document.body.style.backgroundColor = Telegram.WebApp.backgroundColor;
                    
                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–º—É –∏–∑ Telegram
                    if (Telegram.WebApp.colorScheme === 'dark') {
                        document.documentElement.style.setProperty('--bg-color', '#1a1a2e');
                    }
                }
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
                board = createMatrix(COLS, ROWS);
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–Ω–≤–∞—Å–∞
                initCanvas();
                
                // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                setupTouchControls();
                setupButtonControls();
                setupKeyboardControls();
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
                window.addEventListener('resize', () => {
                    initCanvas();
                    draw();
                });
                
                // –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
                update();
                draw();
                
                console.log('üéÆ –ò–≥—Ä–∞ –¢–µ—Ç—Ä–∏—Å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞!');
            }
            
            // –ó–∞–ø—É—Å–∫ –ø—Ä–∏ –ø–æ–ª–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        })();
    </script>
</body>
</html>
