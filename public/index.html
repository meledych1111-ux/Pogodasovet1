<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–¢–µ—Ç—Ä–∏—Å Telegram Mini App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * { 
            margin: 0; padding: 0; box-sizing: border-box; 
            user-select: none; -webkit-tap-highlight-color: transparent; 
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            max-width: 100%;
            height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        .header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 20px;
        }
        
        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .user-info {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .info-label {
            color: #aaccff;
        }
        
        .info-value {
            font-weight: bold;
            color: #4CAF50;
        }
        
        .status-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .status-connected {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }
        
        .status-disconnected {
            background: rgba(244, 67, 54, 0.2);
            color: #F44336;
        }
        
        /* Buttons */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 16px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #00b09b 0%, #96c93d 100%);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f7971e 0%, #ffd200 100%);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
        }
        
        .btn-lg {
            grid-column: span 2;
            padding: 18px;
            font-size: 1.1rem;
        }
        
        /* Game Screen */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #aaccff;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4CAF50;
        }
        
        canvas {
            display: block;
            margin: 0 auto 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            background: rgba(0,0,0,0.5);
            max-width: 100%;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .control-btn {
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.3);
            color: white;
            padding: 15px 5px;
            border-radius: 8px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .control-btn:active {
            background: rgba(102, 126, 234, 0.4);
            transform: scale(0.95);
        }
        
        /* Screens */
        .screen {
            display: none;
            flex: 1;
            animation: fadeIn 0.3s ease;
        }
        
        .screen.active {
            display: flex;
            flex-direction: column;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(33, 150, 83, 0.95);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        .notification.show {
            display: block;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Debug */
        .debug-info {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            color: #aaccff;
            max-height: 100px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Main Menu -->
        <div class="screen active" id="menu-screen">
            <div class="header">
                <h1>üéÆ –¢–ï–¢–†–ò–°</h1>
                <p>Telegram Mini App</p>
                
                <div class="user-info">
                    <div class="info-row">
                        <span class="info-label">–ò–º—è:</span>
                        <span class="info-value" id="username">–ó–∞–≥—Ä—É–∑–∫–∞...</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">ID:</span>
                        <span class="info-value" id="userid">...</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">–ì–æ—Ä–æ–¥:</span>
                        <span class="info-value" id="city">–ù–µ —É–∫–∞–∑–∞–Ω</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Telegram Mini App:</span>
                        <span class="info-value">
                            <span id="telegram-status">–ü—Ä–æ–≤–µ—Ä–∫–∞...</span>
                            <span class="status-badge" id="status-badge"></span>
                        </span>
                    </div>
                </div>
            </div>
            
            <div class="btn-grid">
                <button class="btn btn-primary btn-lg" onclick="startGame()">
                    üéÆ –ù–ê–ß–ê–¢–¨ –ò–ì–†–£
                </button>
                
                <button class="btn" onclick="showStats()">
                    üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê
                </button>
                
                <button class="btn" onclick="showLeaderboard()">
                    üèÜ –õ–ò–î–ï–†–ë–û–†–î
                </button>
                
                <button class="btn btn-warning" onclick="setCity()">
                    üèôÔ∏è –£–ö–ê–ó–ê–¢–¨ –ì–û–†–û–î
                </button>
                
                <button class="btn" onclick="testTelegramAPI()">
                    üîó –¢–ï–°–¢ –¢–ï–õ–ï–ì–†–ê–ú
                </button>
                
                <button class="btn btn-danger" onclick="forceSendToBot()">
                    üì§ –û–¢–ü–†–ê–í–ò–¢–¨ –í –ë–û–¢–ê
                </button>
            </div>
            
            <div class="debug-info" id="debug-log">
                <!-- Debug info will appear here -->
            </div>
        </div>
        
        <!-- Game Screen -->
        <div class="screen" id="game-screen">
            <div class="game-header">
                <button class="btn" onclick="backToMenu()" style="padding: 8px 15px;">
                    ‚Üê –ú–ï–ù–Æ
                </button>
                <div style="text-align: center;">
                    <div style="font-size: 1.2rem; font-weight: bold;">–°—á–µ—Ç: <span id="current-score">0</span></div>
                </div>
                <button class="btn" onclick="saveGame()" style="padding: 8px 15px;">
                    üíæ –°–û–•–†–ê–ù–ò–¢–¨
                </button>
            </div>
            
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">–£–†–û–í–ï–ù–¨</div>
                    <div class="stat-value" id="level">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">–û–ß–ö–ò</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">–õ–ò–ù–ò–ò</div>
                    <div class="stat-value" id="lines">0</div>
                </div>
            </div>
            
            <div style="flex: 1; display: flex; justify-content: center; align-items: center;">
                <canvas id="game-canvas" width="300" height="600"></canvas>
            </div>
            
            <div class="controls">
                <button class="control-btn" onclick="moveLeft()">‚Üê</button>
                <button class="control-btn" onclick="rotatePiece()">‚Üª</button>
                <button class="control-btn" onclick="moveRight()">‚Üí</button>
                <button class="control-btn" onclick="hardDrop()">‚Üì</button>
                <button class="control-btn" onclick="pauseGame()" style="grid-column: span 2;">‚è∏ –ü–ê–£–ó–ê</button>
                <button class="control-btn" onclick="restartGame()" style="grid-column: span 2;">üîÑ –ó–ê–ù–û–í–û</button>
            </div>
        </div>
        
        <!-- Stats Screen -->
        <div class="screen" id="stats-screen">
            <div class="header">
                <h1>üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê</h1>
                <button class="btn" onclick="backToMenu()" style="margin-top: 10px; padding: 8px 20px;">
                    ‚Üê –ù–ê–ó–ê–î
                </button>
            </div>
            
            <div class="user-info">
                <h3 style="margin-bottom: 15px; color: #667eea;">–í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h3>
                <div id="stats-content">
                    <!-- Stats will load here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // ==================== –ö–û–ù–°–¢–ê–ù–¢–´ –ò –ü–ï–†–ï–ú–ï–ù–ù–´–ï ====================
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
        const SHAPES = [
            [[1,1,1,1]],
            [[1,1],[1,1]],
            [[0,1,0],[1,1,1]],
            [[1,1,0],[0,1,1]],
            [[0,1,1],[1,1,0]],
            [[1,0,0],[1,1,1]],
            [[0,0,1],[1,1,1]]
        ];

        // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let tg = null;
        let userId = null;
        let username = '–ò–≥—Ä–æ–∫';
        let userCity = '–ù–µ —É–∫–∞–∑–∞–Ω';
        let isTelegramMiniApp = false;
        let board = [];
        let currentPiece = null;
        let currentX = 0;
        let currentY = 0;
        let score = 0;
        let level = 1;
        let lines = 0;
        let gameActive = false;
        let gamePaused = false;
        let gameOver = false;
        let dropInterval = 1000;
        let lastTime = 0;
        let dropCounter = 0;
        let animationId = null;
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø TELEGRAM ====================
        function initTelegram() {
            logDebug('üîç –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram...');
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ—Ç–∫—Ä—ã—Ç–æ –ª–∏ –≤ Telegram Web App
            if (window.Telegram && window.Telegram.WebApp) {
                tg = window.Telegram.WebApp;
                isTelegramMiniApp = true;
                
                logDebug('‚úÖ –û–±–Ω–∞—Ä—É–∂–µ–Ω Telegram WebApp');
                logDebug(`–í–µ—Ä—Å–∏—è: ${tg.version}`);
                logDebug(`–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: ${tg.platform}`);
                
                // –†–∞—Å—à–∏—Ä—è–µ–º –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω
                tg.expand();
                logDebug('üì± –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–æ');
                
                // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                const initData = tg.initDataUnsafe || {};
                logDebug('–î–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', initData.user);
                
                if (initData.user) {
                    userId = String(initData.user.id);
                    username = initData.user.username || 
                              initData.user.first_name || 
                              'Telegram Player';
                    
                    // –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –≥–æ—Ä–æ–¥
                    if (initData.user.city) {
                        userCity = initData.user.city;
                    } else {
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –≥–æ—Ä–æ–¥
                        const savedCity = localStorage.getItem('tetris_city');
                        if (savedCity) {
                            userCity = savedCity;
                        }
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º sendData
                    const canSendData = typeof tg.sendData === 'function';
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
                    updateTelegramStatus(canSendData);
                    
                    logDebug(`üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${username} (ID: ${userId})`);
                    logDebug(`üìç –ì–æ—Ä–æ–¥: ${userCity}`);
                    logDebug(`üì§ sendData –¥–æ—Å—Ç—É–ø–µ–Ω: ${canSendData}`);
                    
                } else {
                    logDebug('‚ö†Ô∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
                    createWebUser();
                }
                
            } else {
                logDebug('üåê Telegram WebApp –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω, —Ä–∞–±–æ—Ç–∞–µ–º –≤ –±—Ä–∞—É–∑–µ—Ä–µ');
                createWebUser();
            }
            
            updateUserInfo();
            setupGame();
        }

        function createWebUser() {
            userId = 'web_' + Date.now();
            username = 'Web Player';
            isTelegramMiniApp = false;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –≥–æ—Ä–æ–¥
            const savedCity = localStorage.getItem('tetris_city');
            if (savedCity) {
                userCity = savedCity;
            }
            
            logDebug(`üë§ –í–µ–±-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${username} (ID: ${userId})`);
            logDebug(`üìç –ì–æ—Ä–æ–¥: ${userCity}`);
            
            updateTelegramStatus(false);
        }

        function updateTelegramStatus(canSendData) {
            const statusEl = document.getElementById('telegram-status');
            const badgeEl = document.getElementById('status-badge');
            
            if (tg && isTelegramMiniApp) {
                if (canSendData) {
                    statusEl.textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω';
                    badgeEl.textContent = '‚úì';
                    badgeEl.className = 'status-badge status-connected';
                } else {
                    statusEl.textContent = '–û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø';
                    badgeEl.textContent = '‚ö†';
                    badgeEl.className = 'status-badge status-disconnected';
                    logDebug('‚ö†Ô∏è tg.sendData() –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–±—Ä–∞—É–∑–µ—Ä–Ω–∞—è –≤–µ—Ä—Å–∏—è?)');
                }
            } else {
                statusEl.textContent = '–ù–µ –≤ Telegram';
                badgeEl.textContent = 'üåê';
                badgeEl.className = 'status-badge status-disconnected';
            }
        }

        function updateUserInfo() {
            document.getElementById('username').textContent = username;
            document.getElementById('userid').textContent = userId;
            document.getElementById('city').textContent = userCity;
        }

        // ==================== –û–¢–ü–†–ê–í–ö–ê –î–ê–ù–ù–´–• –í –ë–û–¢–ê ====================
        async function sendToBot(gameData) {
            logDebug('üì§ –ü–æ–ø—ã—Ç–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –≤ –±–æ—Ç–∞...');
            
            // –°–ø–æ—Å–æ–± 1: –ß–µ—Ä–µ–∑ Telegram WebApp (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ)
            if (tg && typeof tg.sendData === 'function') {
                try {
                    const botData = {
                        action: 'tetris_game_result',
                        source: 'telegram_mini_app',
                        user_id: userId,
                        username: username,
                        city: userCity,
                        score: gameData.score,
                        level: gameData.level,
                        lines: gameData.lines,
                        game_over: gameData.gameOver || false,
                        timestamp: new Date().toISOString()
                    };
                    
                    logDebug('–û—Ç–ø—Ä–∞–≤–∫–∞ —á–µ—Ä–µ–∑ tg.sendData:', botData);
                    tg.sendData(JSON.stringify(botData));
                    
                    showNotification('‚úÖ –î–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –±–æ—Ç—É');
                    return { success: true, method: 'telegram' };
                    
                } catch (error) {
                    logDebug('‚ùå –û—à–∏–±–∫–∞ tg.sendData:', error);
                }
            }
            
            // –°–ø–æ—Å–æ–± 2: –ß–µ—Ä–µ–∑ API –Ω–∞ –≤–∞—à —Å–µ—Ä–≤–µ—Ä Vercel
            try {
                const apiData = {
                    action: 'tetris_score_from_webapp',
                    user_id: userId,
                    username: username,
                    city: userCity,
                    score: gameData.score,
                    level: gameData.level,
                    lines: gameData.lines,
                    game_over: gameData.gameOver || false,
                    timestamp: new Date().toISOString(),
                    source: isTelegramMiniApp ? 'telegram_webapp' : 'web'
                };
                
                logDebug('–û—Ç–ø—Ä–∞–≤–∫–∞ —á–µ—Ä–µ–∑ API:', apiData);
                
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞—à endpoint –Ω–∞ Vercel
                const response = await fetch('/api/save-score', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(apiData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    logDebug('‚úÖ –û—Ç–≤–µ—Ç API:', result);
                    showNotification('‚úÖ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã —á–µ—Ä–µ–∑ API');
                    return { success: true, method: 'api', data: result };
                } else {
                    throw new Error(`API error: ${response.status}`);
                }
                
            } catch (error) {
                logDebug('‚ùå –û—à–∏–±–∫–∞ API:', error);
            }
            
            // –°–ø–æ—Å–æ–± 3: –°–æ—Ö—Ä–∞–Ω—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
            saveForLater(gameData);
            showNotification('üíæ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –ª–æ–∫–∞–ª—å–Ω–æ');
            return { success: false, method: 'local' };
        }

        function saveForLater(gameData) {
            try {
                const pendingData = {
                    user_id: userId,
                    username: username,
                    city: userCity,
                    score: gameData.score,
                    level: gameData.level,
                    lines: gameData.lines,
                    game_over: gameData.gameOver || false,
                    timestamp: new Date().toISOString(),
                    source: 'pending'
                };
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage
                let pending = JSON.parse(localStorage.getItem('tetris_pending') || '[]');
                pending.push(pendingData);
                
                // –•—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 20 –∑–∞–ø–∏—Å–µ–π
                if (pending.length > 20) {
                    pending = pending.slice(-20);
                }
                
                localStorage.setItem('tetris_pending', JSON.stringify(pending));
                logDebug(`üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –ª–æ–∫–∞–ª—å–Ω–æ. –í—Å–µ–≥–æ –æ–∂–∏–¥–∞—é—â–∏—Ö: ${pending.length}`);
                
                // –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                sendPendingData();
                
            } catch (error) {
                logDebug('‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω–æ:', error);
            }
        }

        async function sendPendingData() {
            try {
                const pending = JSON.parse(localStorage.getItem('tetris_pending') || '[]');
                if (pending.length === 0) return;
                
                logDebug(`üîÑ –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å ${pending.length} –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π...`);
                
                // –ü—Ä–æ–±—É–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —á–µ—Ä–µ–∑ Telegram –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ
                if (tg && typeof tg.sendData === 'function') {
                    for (const data of pending) {
                        try {
                            tg.sendData(JSON.stringify(data));
                            logDebug(`‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–µ: ${data.score} –æ—á–∫–æ–≤`);
                        } catch (error) {
                            logDebug(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–µ:`, error);
                        }
                    }
                    // –û—á–∏—â–∞–µ–º –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
                    localStorage.removeItem('tetris_pending');
                }
                
                // –¢–∞–∫–∂–µ –ø—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ API
                if (pending.length > 0) {
                    try {
                        const response = await fetch('/api/bulk-save', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ games: pending })
                        });
                        
                        if (response.ok) {
                            logDebug(`‚úÖ –û—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã —á–µ—Ä–µ–∑ API`);
                            localStorage.removeItem('tetris_pending');
                        }
                    } catch (error) {
                        logDebug('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ API:', error);
                    }
                }
                
            } catch (error) {
                logDebug('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã—Ö:', error);
            }
        }

        // ==================== –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ====================
        function setupGame() {
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è canvas
            canvas.width = COLS * BLOCK_SIZE;
            canvas.height = ROWS * BLOCK_SIZE;
            
            // –ù–∞—á–∞–ª—å–Ω–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø—É—Å—Ç–æ–≥–æ –ø–æ–ª—è
            board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
            drawBoard();
            
            logDebug('üéÆ –ò–≥—Ä–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞');
            
            // –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            setTimeout(sendPendingData, 2000);
        }

        function startGame() {
            logDebug('üöÄ –ù–∞—á–∞–ª–æ –Ω–æ–≤–æ–π –∏–≥—Ä—ã');
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ä–æ–¥
            if (userCity === '–ù–µ —É–∫–∞–∑–∞–Ω') {
                setCity();
                return;
            }
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—É—é –∏–≥—Ä—É
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // –°–±—Ä–æ—Å –∏–≥—Ä—ã
            board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
            score = 0;
            level = 1;
            lines = 0;
            gameActive = true;
            gamePaused = false;
            gameOver = false;
            dropInterval = 1000;
            
            updateDisplay();
            spawnPiece();
            drawBoard();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω
            showScreen('game-screen');
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
            lastTime = 0;
            dropCounter = 0;
            animationId = requestAnimationFrame(gameLoop);
            
            showNotification('üéÆ –ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å!');
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–±—ã—Ç–∏–µ –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã
            sendToBot({
                action: 'game_start',
                score: 0,
                level: 1,
                lines: 0,
                gameOver: false
            });
        }

        function spawnPiece() {
            const shapeId = Math.floor(Math.random() * SHAPES.length);
            currentPiece = {
                shape: SHAPES[shapeId],
                color: COLORS[shapeId]
            };
            currentX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
            currentY = 0;
            
            if (collide()) {
                gameOver = true;
                endGame();
            }
        }

        function collide(x = currentX, y = currentY, shape = currentPiece.shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardX = x + col;
                        const boardY = y + row;
                        
                        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                            return true;
                        }
                        
                        if (boardY >= 0 && board[boardY][boardX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function mergePiece() {
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        const boardY = currentY + row;
                        const boardX = currentX + col;
                        
                        if (boardY >= 0) {
                            board[boardY][boardX] = currentPiece.color;
                        }
                    }
                }
            }
        }

        function checkLines() {
            let linesCleared = 0;
            
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    linesCleared++;
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                }
            }
            
            if (linesCleared > 0) {
                lines += linesCleared;
                const bonus = [0, 100, 300, 500, 800];
                score += bonus[linesCleared] * level;
                
                if (lines >= level * 10) {
                    level++;
                    dropInterval = Math.max(100, dropInterval - 100);
                    showNotification(`üéâ –£—Ä–æ–≤–µ–Ω—å ${level}!`);
                }
                
                updateDisplay();
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç–∞
                sendToBot({
                    action: 'score_update',
                    score: score,
                    level: level,
                    lines: lines,
                    linesCleared: linesCleared,
                    gameOver: false
                });
            }
        }

        function moveDown() {
            if (!collide(currentX, currentY + 1)) {
                currentY++;
            } else {
                mergePiece();
                checkLines();
                spawnPiece();
            }
            drawBoard();
        }

        function moveLeft() { 
            if (!collide(currentX - 1, currentY)) currentX--; 
            drawBoard(); 
        }
        
        function moveRight() { 
            if (!collide(currentX + 1, currentY)) currentX++; 
            drawBoard(); 
        }

        function rotatePiece() {
            const originalShape = currentPiece.shape;
            const rotated = [];
            const piece = currentPiece.shape;
            
            for (let i = 0; i < piece[0].length; i++) {
                rotated[i] = [];
                for (let j = 0; j < piece.length; j++) {
                    rotated[i][j] = piece[piece.length - 1 - j][i];
                }
            }
            
            currentPiece.shape = rotated;
            if (collide()) {
                currentPiece.shape = originalShape;
            }
            drawBoard();
        }

        function hardDrop() {
            while (!collide(currentX, currentY + 1)) {
                currentY++;
                score += 2;
            }
            mergePiece();
            checkLines();
            spawnPiece();
            updateDisplay();
            drawBoard();
        }

        function pauseGame() {
            if (gameActive && !gameOver) {
                gamePaused = !gamePaused;
                if (gamePaused) {
                    cancelAnimationFrame(animationId);
                    showNotification('‚è∏ –ü–∞—É–∑–∞');
                } else {
                    lastTime = 0;
                    animationId = requestAnimationFrame(gameLoop);
                    showNotification('‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º');
                }
            }
        }

        function restartGame() {
            if (confirm('–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É? –¢–µ–∫—É—â–∏–π –ø—Ä–æ–≥—Ä–µ—Å—Å –±—É–¥–µ—Ç –ø–æ—Ç–µ—Ä—è–Ω.')) {
                startGame();
            }
        }

        function endGame() {
            if (!gameActive) return;
            
            gameActive = false;
            cancelAnimationFrame(animationId);
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            sendToBot({
                action: 'game_over',
                score: score,
                level: level,
                lines: lines,
                gameOver: true,
                finalScore: score
            });
            
            setTimeout(() => {
                showNotification(`üéØ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –°—á–µ—Ç: ${score}`);
                backToMenu();
                loadStats();
            }, 1500);
        }

        function updateDisplay() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lines').textContent = lines;
            document.getElementById('current-score').textContent = score;
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –§–æ–Ω
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –±–ª–æ–∫–∏
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        drawBlock(x, y, board[y][x], false);
                    }
                }
            }
            
            // –¢–µ–∫—É—â–∞—è —Ñ–∏–≥—É—Ä–∞
            if (currentPiece) {
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            drawBlock(currentX + x, currentY + y, currentPiece.color, true);
                        }
                    }
                }
            }
        }

        function drawBlock(x, y, color, isCurrent) {
            const blockX = x * BLOCK_SIZE;
            const blockY = y * BLOCK_SIZE;
            
            ctx.fillStyle = color;
            ctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
            
            ctx.strokeStyle = isCurrent ? 'rgba(255,255,255,0.8)' : 'rgba(0,0,0,0.3)';
            ctx.lineWidth = isCurrent ? 2 : 1;
            ctx.strokeRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
        }

        function gameLoop(time) {
            if (gameOver || gamePaused) return;
            
            const delta = time - lastTime;
            lastTime = time;
            
            dropCounter += delta;
            if (dropCounter > dropInterval) {
                moveDown();
                dropCounter = 0;
            }
            
            drawBoard();
            animationId = requestAnimationFrame(gameLoop);
        }

        // ==================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================
        function logDebug(message, data = null) {
            const debugEl = document.getElementById('debug-log');
            const time = new Date().toLocaleTimeString();
            
            const entry = document.createElement('div');
            entry.style.marginBottom = '5px';
            entry.innerHTML = `<span style="color: #8b9dc3;">[${time}]</span> ${message}`;
            
            if (data) {
                const dataStr = JSON.stringify(data, null, 2);
                entry.innerHTML += `<pre style="color: #aaccff; margin: 5px 0; font-size: 0.7rem;">${dataStr}</pre>`;
            }
            
            debugEl.appendChild(entry);
            debugEl.scrollTop = debugEl.scrollHeight;
            
            console.log(`[${time}] ${message}`, data || '');
        }

        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
            
            logDebug(`üì¢ ${message}`);
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        function backToMenu() {
            if (gameActive && !gamePaused) {
                pauseGame();
            }
            showScreen('menu-screen');
        }

        function showStats() {
            loadStats();
            showScreen('stats-screen');
        }

        function showLeaderboard() {
            loadLeaderboard();
            showScreen('leaderboard-screen');
        }

        function setCity() {
            const newCity = prompt('–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≥–æ—Ä–æ–¥ –¥–ª—è —É—á–∞—Å—Ç–∏—è –≤ —Ä–µ–π—Ç–∏–Ω–≥–µ:', userCity);
            if (newCity && newCity.trim()) {
                userCity = newCity.trim();
                localStorage.setItem('tetris_city', userCity);
                updateUserInfo();
                showNotification(`üìç –ì–æ—Ä–æ–¥ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: ${userCity}`);
            }
        }

        async function saveGame() {
            if (!gameActive || gameOver) return;
            
            showNotification('üíæ –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–≥—Ä—É...');
            
            const result = await sendToBot({
                action: 'game_save',
                score: score,
                level: level,
                lines: lines,
                gameOver: false
            });
            
            if (result.success) {
                showNotification('‚úÖ –ò–≥—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!');
            } else {
                showNotification('üíæ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –ª–æ–∫–∞–ª—å–Ω–æ');
            }
        }

        async function testTelegramAPI() {
            logDebug('üîó –¢–µ—Å—Ç–∏—Ä—É–µ–º Telegram API...');
            
            if (!tg) {
                showNotification('‚ùå Telegram –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω');
                return;
            }
            
            const testData = {
                action: 'test',
                user_id: userId,
                username: username,
                timestamp: new Date().toISOString(),
                message: '–¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ'
            };
            
            if (typeof tg.sendData === 'function') {
                try {
                    tg.sendData(JSON.stringify(testData));
                    showNotification('‚úÖ –¢–µ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —á–µ—Ä–µ–∑ Telegram');
                } catch (error) {
                    showNotification('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —á–µ—Ä–µ–∑ Telegram');
                }
            } else {
                showNotification('‚ö†Ô∏è tg.sendData() –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
            }
        }

        function forceSendToBot() {
            const gameData = {
                score: score || 0,
                level: level || 1,
                lines: lines || 0,
                gameOver: false,
                action: 'manual_send'
            };
            
            sendToBot(gameData);
        }

        async function loadStats() {
            try {
                const response = await fetch(`/api/user-stats?userId=${userId}&gameType=tetris`);
                const statsEl = document.getElementById('stats-content');
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.success && result.stats) {
                        const stats = result.stats;
                        
                        statsEl.innerHTML = `
                            <div class="info-row">
                                <span class="info-label">–õ—É—á—à–∏–π —Å—á–µ—Ç:</span>
                                <span class="info-value">${stats.best_score || 0}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">–ú–∞–∫—Å. —É—Ä–æ–≤–µ–Ω—å:</span>
                                <span class="info-value">${stats.best_level || 1}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">–í—Å–µ–≥–æ –ª–∏–Ω–∏–π:</span>
                                <span class="info-value">${stats.total_lines || 0}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">–ò–≥—Ä —Å—ã–≥—Ä–∞–Ω–æ:</span>
                                <span class="info-value">${stats.games_played || 0}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">–°—Ä–µ–¥–Ω–∏–π —Å—á–µ—Ç:</span>
                                <span class="info-value">${Math.round(stats.avg_score || 0)}</span>
                            </div>
                        `;
                    } else {
                        statsEl.innerHTML = '<p style="color: #ff6666;">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞</p>';
                    }
                } else {
                    statsEl.innerHTML = '<p style="color: #ff6666;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏</p>';
                }
            } catch (error) {
                logDebug('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:', error);
            }
        }

        async function loadLeaderboard() {
            try {
                const response = await fetch('/api/leaderboard?gameType=tetris&limit=10');
                showScreen('leaderboard-screen');
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞...
            } catch (error) {
                logDebug('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞:', error);
            }
        }

        // ==================== –ö–õ–ê–í–ò–ê–¢–£–†–ê ====================
        document.addEventListener('keydown', (e) => {
            if (!document.getElementById('game-screen').classList.contains('active')) return;
            
            switch(e.key) {
                case 'ArrowLeft': e.preventDefault(); moveLeft(); break;
                case 'ArrowRight': e.preventDefault(); moveRight(); break;
                case 'ArrowDown': e.preventDefault(); moveDown(); break;
                case 'ArrowUp': e.preventDefault(); rotatePiece(); break;
                case ' ': e.preventDefault(); hardDrop(); break;
                case 'p': case 'P': e.preventDefault(); pauseGame(); break;
                case 'r': case 'R': e.preventDefault(); restartGame(); break;
                case 'Escape': e.preventDefault(); backToMenu(); break;
                case 's': case 'S': e.preventDefault(); saveGame(); break;
            }
        });

        // ==================== –ó–ê–ü–£–°–ö ====================
        window.addEventListener('load', initTelegram);
    </script>
</body>
</html>
